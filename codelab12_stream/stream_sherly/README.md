# stream_sherly

# Practicum 1: Dart Streams

**Question 1:**

**Add your nickname to titlethe app as an identity for your work.**

<img src="img\q1.png" width="250" alt="1" />

**Question 2:**

**Add 5 more colors as you wish to colorsthe variable.**

<img src="img\q2.png" width="250" alt="1" />

**Question 3:**

<img src="img\q3.png" width="250" alt="1" />

**Explain the function of the keywords yield*in the code!**

yield* is used inside an async generator function (async* function) to return all events from another stream directly.

Meaning:

- yield → sends one single value into the stream.

- yield* → sends all values from another stream, as if they were produced by this function itself.

**What does the content of the code command mean?**

The Stream.periodic(...) function creates a stream that generates data repeatedly every 1 second. The callback (int t) is executed each time the stream emits an event, where t acts as a counter that automatically increases from 0, 1, 2, 3, and so on every second. Inside the callback, int index = t % colors.length uses the modulo operator to ensure that the index cycles through the list of colors repeatedly without going out of bounds. The function then returns colors[index], producing a new color from the list every second. When combined with yield*, all colors generated by Stream.periodic() are forwarded directly as the output stream of the getColors() function within the ColorStream class.

**Question 4:**

<img src="img\q4.gif" width="250" alt="1" />

The GIF shows the background changing colors every second based on the generated stream.

**Question 5:**

<img src="img\q5.gif" width="250" alt="1" />

**Explain the difference between using listen and await for(step 9)!**

- listen attaches a listener callback to the Stream. It does not block the function. The program continues running while the callback is triggered every time the stream emits a new event. This is useful when we want the stream to run in the background and react to its events asynchronously.

- await for is used inside an async function to read events from a Stream sequentially. It waits for each event one at a time and blocks the function until the next event arrives. This makes the code easier to read and ensures the events are processed in order.

# Practicum 2: Stream controllers and sinks

**Question 6:**

**Explain the meaning of the code steps 8 and 10!**

Step 8 sets up the connection between the UI and the stream.
Whenever the stream receives a new number, the UI automatically updates.

Step 10 generates a random number and sends it into the stream, which the UI listens to and updates automatically.

<img src="img\q6.gif" width="250" alt="1" />

**Question 7:**

**Explain the meaning of the code steps 13 to 15!**

Step 13 sends an intentional error into the stream using addError(), allowing you to test how the stream handles error events.

Step 14 uses the onError callback to catch that error and set lastNumber = -1, ensuring the UI remains stable.

Step 15 replaces the random number generation with addError() so the error is triggered intentionally and you can see the error handler working.

<img src="img\q7.gif" width="250" alt="1" />

**Question 8:**

**Explain the meaning of the code steps 1-3!**

Step 1 sets up the declaration of a StreamTransformer that will be used to modify data before it reaches the UI.

Step 2 defines the transformation process, which multiplies each value by 10, replaces any error with -1, and closes the sink when finished.

Step 3 applies the transformer to the stream using .transform(), allowing the UI to receive processed data instead of raw input.

<img src="img\q8.gif" width="250" alt="1" />

**Question 9:**

**Explain the meaning of the code steps 2, 6 and 8!**

Step 2 creates a subscription that listens to the stream. Whenever the stream emits a new value, the UI updates automatically through setState().

Step 6 cancels the subscription inside dispose(). This prevents memory leaks and stops the app from listening to the stream after the page is closed.

Step 8 generates a random number and sends it into the stream only if the stream is still open. If the stream is already closed, the UI shows -1 to indicate that no more data can be added.

<img src="img\q9.gif" width="250" alt="1" />