# stream_sherly

# Practicum 1: Dart Streams

**Question 1:**

**Add your nickname to titlethe app as an identity for your work.**

<img src="img\q1.png" width="250" alt="1" />

**Question 2:**

**Add 5 more colors as you wish to colorsthe variable.**

<img src="img\q2.png" width="250" alt="1" />

**Question 3:**

<img src="img\q3.png" width="250" alt="1" />

**Explain the function of the keywords yield*in the code!**

yield* is used inside an async generator function (async* function) to return all events from another stream directly.

Meaning:

- yield → sends one single value into the stream.

- yield* → sends all values from another stream, as if they were produced by this function itself.

**What does the content of the code command mean?**

The Stream.periodic(...) function creates a stream that generates data repeatedly every 1 second. The callback (int t) is executed each time the stream emits an event, where t acts as a counter that automatically increases from 0, 1, 2, 3, and so on every second. Inside the callback, int index = t % colors.length uses the modulo operator to ensure that the index cycles through the list of colors repeatedly without going out of bounds. The function then returns colors[index], producing a new color from the list every second. When combined with yield*, all colors generated by Stream.periodic() are forwarded directly as the output stream of the getColors() function within the ColorStream class.

**Question 4:**

<img src="img\q4.gif" width="250" alt="1" />

The GIF shows the background changing colors every second based on the generated stream.

**Question 5:**

<img src="img\q5.gif" width="250" alt="1" />

**Explain the difference between using listen and await for(step 9)!**

- listen attaches a listener callback to the Stream. It does not block the function. The program continues running while the callback is triggered every time the stream emits a new event. This is useful when we want the stream to run in the background and react to its events asynchronously.

- await for is used inside an async function to read events from a Stream sequentially. It waits for each event one at a time and blocks the function until the next event arrives. This makes the code easier to read and ensures the events are processed in order.

# Practicum 2: Stream controllers and sinks

**Question 6:**

**Explain the meaning of the code steps 8 and 10!**

Step 8 sets up the connection between the UI and the stream.
Whenever the stream receives a new number, the UI automatically updates.

Step 10 generates a random number and sends it into the stream, which the UI listens to and updates automatically.

<img src="img\q6.gif" width="250" alt="1" />

**Question 7:**

**Explain the meaning of the code steps 13 to 15!**

- Step 13 – Sending an Error into the Stream

The addError() method uses controller.sink.addError('error') to intentionally send an error event into the stream instead of normal data. This helps demonstrate how error events work in a stream.

- Step 14 – Handling Errors with onError

The .onError() callback inside listen() catches any error sent by the stream. When an error occurs, the UI updates lastNumber = -1, allowing the app to respond safely without crashing.

- Step 15 – Triggering the Error

The normal random number generation is replaced with numberStream.addError(). This forces the stream to emit an error, allowing you to test and observe how the error handler updates the UI.

<img src="img\q7.gif" width="250" alt="1" />